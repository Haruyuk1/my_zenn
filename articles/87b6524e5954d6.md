---
title: "dockerを完全に理解しよう その2"
emoji: "🙌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [docker]
published: true
---

# 挨拶

新卒2ヵ月目のおそらく犬です。ストレス解消のためにdockerの公式ドキュメントを読んでいきます。

# はじめに

今回は「Get started - 始めましょう」を読んでいきます。dockerは何もわからない(本当に分からない)ので手を動かしていきます。

> https://docs.docker.jp/get-started/toc.html

以下では上記のドキュメントを適宜引用しています。

# Part1: 始めましょう

## Dockerのダウンロードとインストール

割愛します。適宜導入してください。

## チュートリアルの開始

チュートリアルが始まりました。以下のコマンドをたたきます。

```
$ docker run -d -p 80:80 docker/getting-started
```

docker runの引数が以下のように説明されています。

>- -d - コンテナを デタッチド・モードdetached mode （バックグランドの処理）で 実行
>- -p 80:80 - コンテナ内のポート 80 に対し、ホスト上のポート 80 を割り当てる（ マップmap する）。チュートリアルにアクセスするにはウェブブラウザを開き、 http://localhost:80 に移動する。ホストマシン上で既にサービスがポート 80 をリッスンしている場合、他のポートの指定が必要です。たとえば、 -p 3000:80 を指定すると、チュートリアルにアクセスするにはブラウザで http://localhost:3000 を通します。
> docker/getting-started - 使用するイメージの指定

Widonwsでは80:80は通らなかったので適当に3000:80としたらいけました。人にもよると思いますが。開くとdockerのチュートリアルのページが開きました。

![](/images/87b6524e5954d6/2023-05-11-00-10-35.png)

ローカルでコンテナが動き、コンテナ上で動作しているウェブサーバにアクセスすることができるようになりました。ブラウザのURL欄にlocalhost:3000で自分は繋げました。

## Dockerダッシュボード

> 遠くへと進む前に、 Docker ダッシュボードに焦点をあて、マシン上でのコンテナ実行について素早く目を通したいと思います。Docker ダッシュボードは Mac 、 Windows 、 Linux で利用できます。これを使えばコンテナのログに素早くアクセスでき、コンテナ内でシェルが操作でき、コンテナのライフサイクル（停止、削除、等）の管理が簡単になります。

> ダッシュボードにアクセスするには、 Docker デスクトップのマニュアル にある手順に従ってください。ダッシュボードを開いたら、このチュートリアルで実行しているように見えるでしょう。コンテナ名（ jolly_bouman ）はランダムに作成されます。そのため、以下の画像とは名前が異なるでしょう。

Dockerデスクトップをつかったコンテナ管理の画面が紹介されています。開発者の方はコマンドの方がよりお世話になるのではないでしょうか。

## コンテナとは何？

以下ではどっかーの基本的な実行単位である「コンテナ」について説明されています。

> それでは、コンテナを実行するのですが、コンテナとは何でしょうか？ 簡単に言えば、コンテナとはマシン上でサンドボックス化したプロセスであり、ホストマシン上にある他すべてのプロセスから 隔離isolate されています。この隔離とは カーネルの名前空間と cgroup の活用であり、長らく Linux に存在する機能です。Docker はこれらの 能力capability を、分かりやすく簡単に使えるようにします。まとめると、コンテナとは：

> - 実行可能なイメージの 実体instance 。Docker API や CLI を使ってコンテナの作成、開始、停止、移動、削除ができます。
> - ローカルマシン上や、仮想マシン上えも実行でき、クラウドにもデプロイできます。
> - 可搬性portability があります（多くの OS で実行可能です）。
> - コンテナはお互いに隔離され、それぞれが自身のソフトウェア、バイナリ、設定を使って実行します。

コンテナは実行可能なインスタンスで、様々な環境にデプロイでき、お互いが独立して動くためそれぞれの環境に左右されません。

## コンテナ・イメージとは何でしょうか？

> コンテナの実行時、コンテナは隔離されたファイルシステムを使います。この特別なファイルシステムは コンテナ・イメージ によって提供されます。イメージにはコンテナのファイルシステムも含みますので、アプリケーションを実行するために必要な全てを含む必要があります。たとえば、全ての依存関係、設定、スクリプト、バイナリ等です。また、このイメージには環境変数、デフォルトで実行するコマンド、メタデータのような、他の設定も含みます。
> イメージに関する深掘りは、後のレイヤ化、ベストプラクティス等のトピックで扱います。

ここでのコンテナ・イメージというのは1単語なのでしょうか、2単語なのでしょうか…
とにかくイメージにはアプリケーションの実行に必要なモノ全てが入っているということが言われています。イメージの深堀は今後なされていくようです。

## CLIリファレンス

CLIの仕様については割愛します。

# Part2: サンプルアプリケーション

> 以降のチュートリアルでは、Node.js で動作するシンプルな Todo リスト・マネージャを扱います。Node.js に慣れていなくても、心配無用です。実際の JavaScript 経験を必要としません。

簡単なサンプルでdockerに慣れ親しんでいきます。

> この段階では、あなたの開発チームは非常に小さく、MVP（ 実用最小限の製品Minimum Viable Product ）を検証するためのアプリを構築したばかりです。このアプリが機能する所を見せたいので、この時点では、大きなチームや複数の開発者等が、どのようにして動作させるかを考慮する必要はありません。

とにかくとりあえず動かしてみようということです。

## アプリの入手

リポジトリをここから入手します。

https://github.com/docker/getting-started/tree/master

適当にcloneしてきます。

## アプリのコンテナイメージを構築

> アプリケーションを 構築build するには、 Dockerfile を使う必要があります。 Dockerfile とは、コンテナ イメージの作成で使う命令が、分かりやすい文字列で構成されるスクリプトです。これまでに Dockerfile の作成経験があれば、以下手順にある Dockerfile には問題があると気づくかもしれません。ですが、今は心配しないでください。後ほど説明します。

イメージの作成は基本的にDockerfileを使って行われます。イメージを作成するため、以下のようなDockerfileをapp内に作成します。

```Dockerfile
# syntax=docker/dockerfile:1
FROM node:18-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
EXPOSE 3000
```

そしてapp内で以下のコマンドをたたきます。

```
docker build -t getting-started .
```

これでイメージがビルドされます。6個のコマンドがありますが、1個1個見ていきます。

1つ目はFROM node:18-alpineですが、これはnode:18-alpineイメージを用いてイメージをビルドするということを示しています。
2つ目にWORKDIRとして/appを指定しています。以降のコマンドは基本/appで行われます。
3つ目にCOPYで.から.(/app)へファイルのコピーをしています。つまりソースのコピーです。
4つ目にyarn install --productionで依存関係のDLをしています。
5つ目にコンテナ起動時のコマンドを指定しています。
6つ目でコンテナ外に対して3000番のポートを解放しています。**と読み取れます。**

docker buildコマンドの方では-tオプションでイメージにタグを与えています。そしてそのタグは今回はgetting-startedです。.はDockerfileの検索対象に現在のディレクトリを指定しています。

これでイメージがビルドできました。次はコンテナを建てます。

## アプリコンテナの起動

以下のコマンドでコンテナを起動します。

```
docker run -dp 3000:3000 getting-started
```

> この -d と -p フラグを覚えていますか？ ここでは「 デタッチドdetouched モード」（バックグランドで）新しいコンテナを実行し、ホスト側のポート 3000 をコンテナのポート 3000 間で関連付け（ マッピングmapping ）をします。ポートの関連付け（ ポート マッピングport mapping ）をしなければ、アプリケーションに接続できません。

-dオプションはバックグラウンドでの動作で、-pはポートのマッピングをするオプションです。

> 数秒後、自分のウェブ ブラウザで http://localhost:3000 を開きます。そうすると、私たちのアプリが見えるでしょう。

ローカルの3000番へアクセスすると見れます。簡単にアプリケーションを実行することができました。

## まとめ

> この短いセクションでは、基本中の基本として、コンテナ イメージの構築と、 Dockerfile の作成とイメージの構築を学びました。イメージを構築するだけでコンテナを実行でき、実行中のアプリを表示しています。

> 次はアプリに変更を加え、実行中のアプリケーションを新しいイメージに更新する方法を学びます。その途中で、いくつかの便利なコマンドも学びます。

あくまでここでは簡単なdockerのチュートリアルを学びました。この後詳細な説明がなされるでしょう。

# アプリケーションの更新

前章でアプリケーションをコンテナ化して動かしてみました。アプリケーションが変更された時、イメージとコンテナはどうなるでしょうか。見ていきます。

## ソースコードの変更

以下のようにソースコードを変更した後、再びビルドしてコンテナを立てると以下のようなメッセージが出ます。

```
docker: Error response from daemon: driver failed programming external connectivity on endpoint laughing_burnell
(bb242b2ca4d67eba76e79474fb36bb5125708ebdabd7f45c8eaf16caaabde9dd): Bind for 0.0.0.0:3000 failed: port is already allocated.
```

## 古いコンテナを置き換える

これは前に立てたコンテナがまだ生きていて、ポートが占有されているからです。前のコンテナを潰すにはdocker psコマンドを使って潰したいコンテナIDを調べ、指定して潰します。

> docker rm <the-container-id>

## Dockerダッシュボードでコンテナを削除

Dockerデスクトップを使っている場合にはGUIから消せます。

## 更新したアプリ用コンテナを起動

再び起動すると更新が反映されていることが分かります。

これが開発規模が大きくなってもベストプラクティスと呼べる方法なのかは分からないですが、とりあえず動くことには動きます。

## まとめ

> 構築と更新をしましたが、注意点が２つあります。
> - todo リストに追加していたアイテムは、全て消えました！ あまり良くないアプリですね！ 近いうちに説明します。
> 小さな変更のように、実際には多くの改良ステップがあります。以降のセクションでは、再構築を必要としないコードの編集方法や、変更する度に新しくコンテナを起動する方法を説明します。

コンテナは基本的に内部状態を保持しません。なのでコンテナが消えるとTODOリストも消えました。またイメージの再構築を必要としないコードの編集方法など、今後は様々な需要の場面にあったケースを見ていけそうです。自分の開発にあった方式を模索したいです。

> 一貫性persistence を説明する前に、他人とイメージを共有する方法を見ていきます。

一貫性という言葉が出てきました。コンテナをビルドしたときの話でしょうか。一貫性、いい響きですね。

# おわりに

今回はdockerの日本語ドキュメントのget startedのPart1から3を見てきました。まだ導入ですね、ただホストPC上に環境を用意することなくdockerだけでアプリケーションが動くというのは非常に簡単で便利であることが分かったと思います。次回もよろしくお願いします。
