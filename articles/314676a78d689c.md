---
title: "dockerを完全に理解しよう その1"
emoji: "🐷"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [docker]
published: false
---

# 挨拶

どうも、新卒一年目のエンジニアのおそらく犬です。Pythonについて完全に理解したかったんですが、そんなことよりも業務のアジャイル(手動ビルド、手動テスト、手動デプロイ)の**ストレスが半端なく**、一秒でも早くこれらの作業を自動化したいためdockerの勉強をします。そのメモをここに書き残します。

間違いがあれば指摘いただけると嬉しいです。よろしくお願いいたします。

# はじめに

いつものように公式のドキュメントを読んでいきます。待エソジニアはダメです。

https://docs.docker.jp/

こちらより引用させていただきます。

# Dockerの概要

> Docker はアプリケーションを開発（developing）、移動（shipping）、実行（running）するためのオープンなプラットフォームです。Docker はインフラストラクチャ 1 とアプリケーションを切り離すため、ソフトウェアを短時間で提供できます。Docker があれば、アプリケーションを管理するのと同じ方法で、あなたのインフラも管理できます。Docker 的な手法を最大限活用しますと、テストやコードのデプロイを素早くできますので、コードを書いてから、プロダクション（実行環境）で動かすまでにかかる時間を著しく軽減できます。

なんかふわっとしたこと書いてますね。この後伏線回収していくと思うのでここは流し見で良いでしょう。要素としては

- インフラとアプリを切り離す
- インフラを管理できる
- テストやデプロイが素早く実行できるようになる

の3つがあります。これが嬉しい点です。詳細はこの後出てくると思います。

# Dcoker プラットフォーム

> Docker は、コンテナ（container）という緩やかに隔離された環境 2 （isolated environment）で、アプリケーションのパッケージ化と実行をする機能を提供します。この分離と安全性により、実行するホスト上で多くのコンテナを同時に実行できます。コンテナは軽量であり、アプリケーションの実行に必要な全てが入っているため、ホスト上で今何をインストールしていようが関係ありません。作業中でも手軽にコンテナを共有できますので、あなたが共有したコンテナを得た全ての人が、同じコンテナを、同じ方法で、確実に動作できるようにします。

つまりdockerではアプリケーションはコンテナ上で動きます。ホストの環境は関係ありません。
良くある話ですが環境には様々な要素があります。OS、アプリケーション、ライブラリなどなどです。

昔はアプリケーションを動かす環境と作成する環境は基本的に同じであったと聞いています。ただこれは大変な苦労があり、いつでも同じ環境が作れるとは限らないことです。様々な要因が考えられますがここでは割愛します。

しかしこれらを考えなくてよくなるのがdockerです。`コンテナは軽量であり、アプリケーションの実行に必要な全てが入っているため、ホスト上で今何をインストールしていようが関係ありません。`とありますが、これのおかげで我々は開発環境と動作環境の違いを考慮しなくて済むようになっています。これが`インフラとアプリを切り離す`を指しています。

> Docker が提供するのは、コンテナのライフサイクル（全過程）を管理するツールと、プラットフォームです。

> - コンテナを利用して、アプリケーションとそれをサポートするコンポーネント 3 を開発。
> - コンテナは、アプリケーションの配布とテストをする単位。
> - 準備ができたら実環境（運用環境）にアプリケーションをデプロイします。デプロイの単位は、１つのコンテナか、あるいはオーケストレーション（orchestrated 4 ）された１つのサービスです。あなたの実環境は、構内のデータセンタやクラウドプロバイダや、あるいは両者の組み合わせ（ハイブリッド）でも動作します。

1点目はdockerはアプリケーションの開発を支援するコンポーネントが含まれていますということを言っています。
2点目は1つのコンテナは1つのアプリケーションを積めと言っています。
3点目はコンテナを出荷して実環境に出せということですね。

**あらゆる環境で動作する**、それがdockerの強みだと言えそうです。

## 素早く一貫性を保つアプリケーションのデリバリ

> Docker は開発のライフサイクルを効率化します。開発するアプリケーションやサービスがローカルなコンテナ内に実現でき、開発者は標準化された環境により作業が進められるからです。コンテナを使った開発は、継続的インテグレーション (continuous integration; CI) や継続的開発 (continuous delivery; CD) のワークフローに適しています。

1人1人で環境を作るのはクソ大変です。必要なライブラリのインストールなどは増えれば増えるほど辛い。そういったものをdockerはコンテナ内に全て実現します。開発者は嬉しい。俺も早くうれしくなりたい。

CIは自動でビルドやテストをすること、CDは自動でデリバリー(あるいはデプロイ)することです。早く自動になりたい。

> 以下のようなシナリオ例を検討しましょう。

> - 開発者がローカルでコードを書き、仲間とその作業を共有するために Docker コンテナを使います。
> - Docker によりアプリケーションをテスト環境に投入し、自動および手動のテストを実行します。
> - 開発者がバグを発見したら、開発環境においてこれを修正して、アプリケーションをテスト環境に再デプロイし、テスト確認を行ないます。
> - テストが完了します。この後にユーザが修正版を利用できるようにすることは、更新済イメージを本番環境へ投入することと同じく容易なことです。

みんな同じ環境で開発出来て、自動でテストしてくれて、そのままデプロイもできる。現代のソフトウェア開発はこうあるべきですね。全部手動で環境構築して、手動でビルドして、手動でテストして、手動でデプロイなんかしてたら時間も金も足りなくなります。新規プロジェクトはまずこれを徹底してほしいものです。

## 迅速なデプロイとスケーリング

> Docker によるコンテナベースのプラットフォームは、処理負荷の高度な分散を考慮しています。Docker コンテナは、開発者のノートパソコン上で実行できるだけでなく、データセンタの物理マシンや仮想マシン、クラウドプロバイダ、そしてさまざまな環境の組み合わせにおいて実行可能です。

ホストマシンの性能に対してスケーラブルということでしょうか。どのようにスケール出来るのかはまだよくわかんないです。

> Docker の可搬性と軽量な特性は、以下のようなことを容易に実現します。それは処理負荷を動的に管理できること、ビジネスシーンでの要求に応じてアプリケーションのスケールアップや提供終了を簡単に、しかもほぼリアルタイムで行うことができます。

ここでもスケーラビリティがあるということを主張しています。具体的な方法は後で出てくるでしょう。

## 同じハードウェア上で負荷の高い処理を実行

> Docker は軽量かつ高速です。ハイパーバイザ・ベースの仮想マシンに取って変わる、実用的で費用対効果の高いものです。したがってコンピュータ性能をフルに活用してビジネス目標を達成できます。Docker は高度に処理集中する環境に適しており、さらには中小規模の、より少ないリソースの中でのシステム構築にも適しています。

これはさんざん言われていますがハイパーバイザベースの仮想マシンはアプリだけでなくOSも乗っかるので重いと言われていますね。

# Dockerのアーキテクチャ

> Docker はクライアント・サーバ型のアーキテクチャを採用しています。Docker クライアント は Docker デーモンに処理を依頼します。このデーモンは、Docker コンテナの構築、実行、配布という複雑な仕事をこなします。Docker クライアントとデーモンは同一システム上で動かすことも 可能 ですが、別のシステム上であっても、Docker クライアントからリモートにある Docker デーモンへのアクセスが可能です。Docker クライアントとデーモンの間の通信には REST API が利用され、UNIX ソケットまたはネット・ワークインターフェイスを介して行われます。他にも Docker クライアントには Docker Compose があり、コンテナ一式で構成されるアプリケーションを操作します。

dockerのコマンドをたたいた時のプロセスがクライアント、Dockerデーモンがあるのがサーバーという形っぽいです。Dockerデーモンは別に同一システム上になくてもいいんですね。またクライアントには亜種としてDocker Composeがあるとのこと。Composeは複数のコンテナからなる1つのサービスを構成するときに使用します。

## Dockerデーモン

> Docker デーモン（ dockerd ）は Docker API リクエストを受け付け、イメージ、コンテナ、ネットワーク、ボリュームといった Docker オブジェクトを管理します。また、Docker サービスを管理するため、他のデーモンとも通信を行います。

イメージ、ネットワーク、ボリュームという言葉が出てきますが、おそらく後で詳細な解説が入ります。まあデーモンさんがだいたいよしなにしてくれるらしいですね。

## Dockerクライアント

> Docker クライアント（ docker ）は Docker とのやりとりを行うために、たいていのユーザが利用するものです。docker run のようなコマンドが実行されると、Docker クライアントは dockerd にそのコマンドを伝えます。そして dockerd はその内容を実現します。docker コマンドは Docker API を利用しています。Docker クライアントは複数のデーモンと通信することができます。

コマンドをたたくとそれがクライアントになって要件を伝えるだけっぽいです。

## Dockerデスクトップ

> Docker デスクトップは Mac や Windows や Linux 環境へ簡単にインストールできるアプリケーションです。これを使えば、 コンテナ化containerlized したアプリケーションとマイクロサービスを構築・共有できるようになります。Docker デスクトップに含まれるのは Docker デーモン（ dockerd ）、Docker クライアント（ docker ）、Docker Compose、Docker Content Trust、Kubernetes、 Credential Helper認証情報ヘルパー です。詳しい情報は Docker Desktop をご覧ください。

要は簡単に扱えるようにしてくれるよーんなアプリケーションですね。企業の場合は有料になる場合があるのでしっかり調べてください。導入拒否られたら…、転職しましょう。

## Dockerレジストリ

> Docker レジストリは Docker イメージを保管します。Docker Hub は公開レジストリであり、誰でも利用可能です。また Docker はデフォルトで Docker Hub のイメージを探すよう設定されています。独自にプライベート・レジストリを運用することもできます。

イメージやコンテナなどまだ習ってない単語が出てきますがイメージはオブジェクト指向におけるクラス、コンテナはインスタンスみたいなイメージでいいと思います。

またDocker HubというGitHubみたいなものがあります。いろんなイメージがあってゲームのサーバー建てるときとか結構お世話になりますね。だいたい揃ってます。

> docker pull や docker run コマンドを使うと、設定されたレジストリから必要なイメージを取得します。 docker push コマンドを使えば、イメージを指定したレジストリに送信します。

GitHubのようにイメージをダウンロードしてきたりアップロードしたりできます。もちろんイメージの利用は自己責任で。

## Dockerオブジェクト

> Docker の利用時は、イメージ、コンテナ、ネットワーク、ボリューム、プラグインや、その他のオブジェクトを作成・利用します。このセクションは各オブジェクトの概要を説明します。

Dockerには様々なオブジェクトが存在するようです。イメージ・コンテナは簡単に説明しましたが残りは謎なので見ていきましょう。

### イメージ

> イメージ（ image ）とは、Docker コンテナを作成する命令が入った読み込み専用のテンプレートです。通常イメージは、他のイメージをベースにしてそれをカスタマイズして利用します。たとえば ubuntu イメージをベースとするイメージを作ったとします。そこには Apache ウェブ・サーバや自開発したアプリケーションといったものをインストールするかもしれません。さらにアプリケーション実行に必要となる詳細な設定も加えることにもなるでしょう。

イメージはオブジェクト指向でいうクラスみたいなものと説明しました。イメージはさらに継承みたいなカスタマイズが出来ることが書かれています。基本的にアプリケーションを動かすためのものがほぼ入っています。逆にコンテナ外部の環境に依存するのは悪い設計と言えるかもしれません。有識者の方教えてください。

> イメージは作ろうと思えば作ることができ、他の方が作ってレジストリに公開されているイメージを使うということもできます。イメージを自分で作る場合は Dockerfile というファイルを生成します。このファイルの文法は単純なものであり、そこにはイメージを生成して実行するまでの手順が定義されます。Dockerfile 内の個々の命令ごとに、イメージ内にはレイヤというものが生成されます。Dockerfile の内容を書き換えたことでイメージが再構築されるときには、変更がかかったレイヤのみが再生成されます。他の仮想化技術に比べて Dockerイメージというものが軽量、小さい、早いを実現できているのも、そういった部分があるからです。

重要なことが書いてあります。イメージは主に2つの方法で利用が可能です。

- レジストリに公開されているものを作る
- 自分でDockerfileを作成し、イメージを作る

DockerfileはGithubの親切なリポジトリにはおいてあることが多いですね。簡単な文法で記述可能で、イメージを作るときの手順を示すだけで良いらしいです。Dockerfile内の個々の命令に対してレイヤというものが作成され、命令に変更があった場合にはそれに対応するレイヤのみが変わる、という設計になっています。イメージに変更があった時、そのレイヤの差分のみを取得すればよいので変更があっても早く移植することが可能です。

### コンテナ

> コンテナとは、イメージが実行状態となったインスタンスのことです。コンテナに対する生成、開始、停止、移動、削除は Docker API や CLI を使って行われます。コンテナは、複数のネットワークへの接続、ストレージの追加を行うことができ、さらには現時点の状態にもとづいた新たなイメージを生成することもできます。

コンテナに対する操作が説明されています。イメージからコンテナを作るというだけではなく、逆にコンテナからイメージも作れるというのは初耳でした。

> デフォルトでは、コンテナは他のコンテナやホストマシンとは、程よく分離されています。コンテナに属するネットワーク、ストレージ、基盤となるサブシステムなどを、いかにして他のコンテナやホストマシンから切り離すか、その程度は制御することが可能です。

程よく分離されています、うーん分からない。ここは今後の詳細に期待するしかなさそうです。

> コンテナはイメージによって定義されるものです。またこれを生成、実行するために設定したオプションによっても定義されます。コンテナを削除すると、その時点での状態に対して変更がかかっていたとしても、永続的なストレージに保存されていないものは消失します。

コンテナ = instantiate(イメージ, オプション)という感じですかね。コンテナは設定をしなければ何かを外部に保存したりはしないので例えばコンテナ内に出力を出してたりした場合、コンテナを削除すればそれは消えます。

#### docker run コマンドの例

> 次のコマンドは ubuntu コンテナを実行し、ローカルのコマンドライン処理のセッションを結びつけます。そして /bin/bash を実行します。

```
$ docker run -i -t ubuntu /bin/bash
```

ところで$付きのクリップボードにわんぽちでコピー可能なコードブロックは犯罪だと思ってる。

> このコマンドを実行すると、以下のようになります（デフォルトのレジストリ設定を使用している想定です）。

先に説明しますがdocker runコマンドは複数のコマンドをひとまとめにしたものと思ってよさそうです。

>1. ubuntu イメージがローカルになければ、Docker は設定されているレジストリからイメージを取得します。この動作は手動で docker pull ubuntu を実行するのと同じです。

なければ取ってきてくれるらしい。賢い。

>2. Docker は新しいコンテナを作成します。これは手動で docker create コマンドを実行するのと同じです。

>3. Docker はコンテナに対して読み書き可能なファイルシステムを、最後のレイヤとして割り当てます。このため、実行中のコンテナは、コンテナ内のローカルなファイルシステムで、ファイルやディレクトリの生成や変更ができます。

最後のレイヤはファイルシステムのレイヤと決まっているそうです。

>4. Docker はネットワーク・インターフェースを生成し、コンテナをデフォルト・ネットワークに接続します。これは、ネットワークのオプションを一切指定していないからです。この処理には、コンテナに対する IP アドレスの割り当ても含みます。デフォルトでは、コンテナが外部ネットワークに接続するには、ホストマシンのネットワーク接続を利用します。

デフォルト設定ではDockerを動かすホストマシンへの特定ポートへの接続=そのポートが設定されているコンテナへの設定になるようです。コンテナ側から見ても然り。

>5. Docker はコンテナを起動し、 /bin/bash を実行します。コンテナは（ -i と -t のフラグにより）対話的に、かつターミナルに接続して実行しているため、手元のキーボードを使って入力でき、その間の出力はターミナル上に表示されます。

-iオプションがinteractiveになるオプションで-tオプションがterminalに接続するオプションということですね。要は普段使っているターミナルっぽく使えます、ということです。

>6. exit を入力すると、 /bin/bash コマンドは終了します。コンテナは停止状態となりますが、削除はされません。コンテナは再起動や削除できます。

コンテナで作動しているプロセスが終了するとコンテナは停止状態になるだけで削除はされませんとのことです。

# 基礎技術

> Docker は Go プログラミング言語 で書かれており、Linux カーネルの機能をうまく活用して、さまざまな機能性を実現しています。Docker は namespaces （名前区間）技術を使い、「 コンテナcontainer 」と呼ぶ 隔離された作業空間isolated workspace を準備します。

Go is GOD.

> 名前空間はいくつもの隔離状態を作り出します。コンテナ内のさまざまな処理は、隔離された名前空間内で実行され、それぞれへのアクセスはその名前空間内に限定されます。

基本的にはコンテナ同士のそれぞれの動作はお互いに影響されることはないという意味と捉えてよいんでしょうか。

# 終わりに

ぶっちゃけこれだけでは理解出来ないですが、dockerが「環境」という最大の頭悩ませ要素を排除できるツールだということです。次章、「Dockerの入手」は割愛し「Get started - 始めましょう」を読んでいきます。
